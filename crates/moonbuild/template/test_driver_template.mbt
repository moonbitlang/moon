// Generated by moon test.

fn catch_exception[A](body : A, on_exn : A) -> A = "%control.catch"

fn check_panic[A, B, E : Error](
  f : () -> A!E,
  does_panic : () -> B!E,
  no_panic : () -> B!E
) -> B!E {
  catch_exception(
    {
      f!() |> ignore
      no_panic!()
    },
    does_panic!(),
  )
}

fn error_to_string(x : Error) -> String = "%error.to_string"

fn startswith_panic(s : String) -> Bool {
  s.length() >= 5 && s[0] == 'p' && s[1] == 'a' && s[2] == 'n' && s[3] == 'i' &&
  s[4] == 'c'
}

typealias TestDriver_No_Args_Function = () -> Unit!Error

typealias TestDriver_With_Args_Function = (@moonbitlang/core/test.T) -> Unit!Error

typealias TestDriver_No_Args_Map = @moonbitlang/core/builtin.Map[
  String,
  @moonbitlang/core/builtin.Map[
    Int,
    (TestDriver_No_Args_Function, @moonbitlang/core/builtin.Array[String]),
  ],
]

typealias TestDriver_With_Args_Map = @moonbitlang/core/builtin.Map[
  String,
  @moonbitlang/core/builtin.Map[
    Int,
    (TestDriver_With_Args_Function, @moonbitlang/core/builtin.Array[String]),
  ],
]

struct TestDriver__Meta {
  filename : String
  index : Int
  attrs : @moonbitlang/core/builtin.Array[String]
}

enum TestDriver__F {
  F0(TestDriver_No_Args_Function)
  F1(TestDriver_With_Args_Function)
}

struct TestDriver__TestCase {
  f : TestDriver__F
  meta : TestDriver__Meta
}

fn apply_filter(
  no_args_tests : TestDriver_No_Args_Map,
  with_args_tests : TestDriver_With_Args_Map,
  file_filter : String?,
  index_filter : Int?
) -> @moonbitlang/core/builtin.Array[TestDriver__TestCase] {
  let ret = []
  no_args_tests.iter().each(
    fn(file) {
      let filename = file.0
      match file_filter {
        Some(f) => if filename != f { return  }
        _ => ()
      }
      let testss = file.1
      testss.iter().each(
        fn(cases) {
          let index = cases.0
          match index_filter {
            Some(f) => if index != f { return  }
            _ => ()
          }
          let k = {
            f: TestDriver__F::F0(cases.1.0),
            meta: { filename, index, attrs: cases.1.1 },
          }
          ret.push(k)
        },
      )
    },
  )
  with_args_tests.iter().each(
    fn(file) {
      let filename = file.0
      match file_filter {
        Some(f) => if filename != f { return  }
        _ => ()
      }
      let testss = file.1
      testss.iter().each(
        fn(cases) {
          let index = cases.0
          match index_filter {
            Some(f) => if index != f { return  }
            _ => ()
          }
          let k = {
            f: TestDriver__F::F1(cases.1.0),
            meta: { filename, index, attrs: cases.1.1 },
          }
          ret.push(k)
        },
      )
    },
  )
  ret
}

let tests : Map[String, Array[(() -> Unit!Error, Array[String])]] = { }
let no_args_tests : Map[String, Map[Int, (() -> Unit!Error, Array[String])]] = { }
let with_args_tests : Map[String, Map[Int, ((@test.T) -> Unit!Error, Array[String])]] = { }
// REPLACE ME 0

fn main {
  let _ = tests
  let file_filter: String? = Some(get_file_name())
  let index = get_index()
  let index_filter : Int? = Some(parse_int_(index))
  let filtered_tests = apply_filter(no_args_tests, with_args_tests, file_filter, index_filter)
  let total = filtered_tests.length()
  let test_names = @moonbitlang/core/builtin.Array::make(total, "")
  let filenames = @moonbitlang/core/builtin.Array::make(total, "")
  let messages = @moonbitlang/core/builtin.Array::make(total, "")
  let mut succ_idx = total
  let mut fail_idx = 0
  let mut counter = 0
  for i = 0; i < filtered_tests.length(); i = i + 1 {
    let item = filtered_tests[i]
    let filename = item.meta.filename
    filenames[counter] = filename
    counter += 1
    let attrs = item.meta.attrs
    let name = if attrs.is_empty() { "" } else { attrs[0] }
    let name = if name.length() == 0 {
      item.meta.index.to_string()
    } else {
      name
    }
    try {
      let f = match item.f {
        TestDriver__F::F0(f) => f
        TestDriver__F::F1(f) =>
          fn() {
            let it : @moonbitlang/core/test.T = {
              name,
              buffer: Buffer::new(),
            }
            f!(it)
          }
      }
      if startswith_panic(name) {
        check_panic!(
          f,
          fn() { () },
          fn() { raise Failure("panic is expected") },
        )
      } else {
        f!()
      }
      succ_idx -= 1
      test_names[succ_idx] = name
    } catch {
      Failure(e) | InspectError(e) | SnapshotError(e) => {
        test_names[fail_idx] = name
        messages[fail_idx] = e
        fail_idx += 1
      }
      e => {
        test_names[fail_idx] = name
        messages[fail_idx] = error_to_string(e)
        fail_idx += 1
      }
    }
  }
  fn repr(obj : @moonbitlang/core/builtin.Array[String]) -> String {
    let buf = @moonbitlang/core/builtin.Buffer::new(size_hint=16)
    Show::output(obj[0], buf)
    buf.to_string()
  }

  let filenames = repr(filenames)
  let test_names = repr(test_names)
  let messages = repr(messages)
  let _passed = total - succ_idx
  println("{BEGIN_MOONTEST}")
  println(
    "{\"package\": \"{PACKAGE}\", \"filename\": \{filenames}, \"index\": \"\{index}\", \"test_name\": \{test_names}, \"message\": \{messages}}",
  )
  println("{END_MOONTEST}")
}

fn parse_int_(s : String) -> Int {
  let mut res = 0
  let len = s.length()
  for i = 0; i < len; i = i + 1 {
    res = res * 10 + (s[i].to_int() - '0'.to_int())
  }
  res
}

// =========== ffi start ===========

fn _get_file_name() -> ExternString = "test" "get_file_name"
fn get_file_name() -> String {
  let file_name = _get_file_name()
  string_from_extern(file_name)
}

fn _get_index() -> ExternString = "test" "get_index"
fn get_index() -> String {
  let index = _get_index()
  string_from_extern(index)
}

type JSValue

pub fn jsvalue_is_string(v : JSValue) -> Bool = "__moonbit_fs_unstable" "jsvalue_is_string"

pub fn jsvalue_get_string(v : JSValue) -> ExternString = "%identity"

pub type JSArray

pub fn array_len(arr : JSArray) -> Int = "__moonbit_fs_unstable" "array_len"

pub fn array_get(arr : JSArray, idx : Int) -> JSValue = "__moonbit_fs_unstable" "array_get"

pub fn JSArray::op_get(self : JSArray, idx : Int) -> JSValue {
  return array_get(self, idx)
}

type StringCreateHandle

type StringReadHandle

pub type ExternString

fn begin_create_string() -> StringCreateHandle = "__moonbit_fs_unstable" "begin_create_string"

fn string_append_char(handle : StringCreateHandle, ch : Char) = "__moonbit_fs_unstable" "string_append_char"

fn finish_create_string(handle : StringCreateHandle) -> ExternString = "__moonbit_fs_unstable" "finish_create_string"

pub fn string_to_extern(s : String) -> ExternString {
  let handle = begin_create_string()
  let len = s.length()
  for i = 0; i < len; i = i + 1 {
    string_append_char(handle, s[i])
  }
  finish_create_string(handle)
}

fn begin_read_string(s : ExternString) -> StringReadHandle = "__moonbit_fs_unstable" "begin_read_string"


fn string_read_char(handle : StringReadHandle) -> Int = "__moonbit_fs_unstable" "string_read_char"

fn finish_read_string(handle : StringReadHandle) = "__moonbit_fs_unstable" "finish_read_string"

pub fn string_from_extern(e : ExternString) -> String {
  let buf = Buffer::new()
  let handle = begin_read_string(e)
  while true {
    let ch = string_read_char(handle)
    if ch == -1 {
      break
    } else {
      buf.write_char(Char::from_int(ch))
    }
  }
  finish_read_string(handle)
  buf.to_string()
}

// =========== ffi end ===========